// Both of these suggestions from ReSharper should be ignored.  If the properties are private or 'get-only' then they
// can't be De/Serialized properly
// ReSharper disable AutoPropertyCanBeMadeGetOnly.Global
// ReSharper disable MemberCanBePrivate.Global

// This was regarding the GetHashCode function generated by Rider which ReSharper then complained about it
// ReSharper disable NonReadonlyMemberInGetHashCode

namespace ConfigurationTest.Configs;

public class BasicConfig : IEquatable<BasicConfig>
{
	// TODO: Characters get converted to integers by the XML serializer, but the JSON serializer works perfectly
	// The setters have to exist (despite the optimization ReSharper suggests), or these won't serialize properly
	public char CharValue { get; set; } = Constants.CharValue;
	public int IntegerValue { get; set; } = Constants.IntegerValue;
	public float FloatValue { get; set; } = Constants.FloatValue;
	public string StringValue { get; set; } = Constants.StringValue;

	public BasicConfig() { }

	public BasicConfig(char c, int i, float f, string s)
	{
		CharValue = c;
		IntegerValue = i;
		FloatValue = f;
		StringValue = s;
	}

	public override string ToString()
	{
		return $"{CharValue} | {IntegerValue} | {FloatValue} | {StringValue}";
	}

	public bool Equals(BasicConfig? other)
	{
		if (ReferenceEquals(null, other)) return false;
		if (ReferenceEquals(this, other)) return true;
		return CharValue == other.CharValue
		       && IntegerValue == other.IntegerValue
		       && FloatValue.Equals(other.FloatValue)
		       && StringValue == other.StringValue;
	}

	public override bool Equals(object? obj)
	{
		if (ReferenceEquals(null, obj)) return false;
		if (ReferenceEquals(this, obj)) return true;
		return obj.GetType() == GetType()
		       && Equals((BasicConfig)obj);
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(CharValue, IntegerValue, FloatValue, StringValue);
	}
}